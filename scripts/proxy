#!/usr/bin/python3

from http.server import SimpleHTTPRequestHandler
from urllib.parse import urlparse
from socketserver import TCPServer
from hashlib import sha256
from ecdsa import SECP256k1, SigningKey
import traceback
import sys
import requests
import json

# WabiSabi server rejects cross-origin requests from trezor-suite
# This proxy will override request headers
WABISABI_HOST = "127.0.0.1:37127"
WABISABI_HEADERS = {
    "Host": WABISABI_HOST,
    "Origin": f"http://{WABISABI_HOST}",
}

MIDDLEWARE_HOST = "127.0.0.1:37128"
MIDDLEWARE_HEADERS = {
    "Host": MIDDLEWARE_HOST,
    "Origin": f"http://{MIDDLEWARE_HOST}",
}

# origin is set to the actual machine that made the call not localhost
def merge_headers(original: dict, override: dict) -> dict:
    headers = original.copy()
    headers.update(override)
    return headers


# Simplified payment request from:
# https://github.com/trezor/trezor-firmware/blob/master/tests/device_tests/bitcoin/test_signtx_payreq.py

payment_req_signer = SigningKey.from_string(
    b"?S\ti\x8b\xc5o{,\xab\x03\x194\xea\xa8[_:\xeb\xdf\xce\xef\xe50\xf17D\x98`\xb9dj",
    curve=SECP256k1,
)

def hash_bytes_prefixed(hasher, data):
    hasher.update(len(data).to_bytes(1, "little"))
    hasher.update(data)


def make_payment_request(
    recipient_name, outputs, change_addresses
):
    slip44 = 1  # Testnet

    h_pr = sha256(b"SL\x00\x24")
    h_pr.update(b"\0")

    hash_bytes_prefixed(h_pr, recipient_name.encode())

    memos = []
    h_pr.update(len(memos).to_bytes(1, "little"))
    h_pr.update(slip44.to_bytes(4, "little"))

    change_address = iter(change_addresses or [])
    h_outputs = sha256()
    for txo in outputs:
        h_outputs.update(txo['amount'].to_bytes(8, "little"))
        address = txo.get('address', None) or next(change_address)
        print(address)
        h_outputs.update(len(address).to_bytes(1, "little"))
        h_outputs.update(address.encode())

    h_pr.update(h_outputs.digest())

    return {
        "recipient_name": recipient_name,
        "amount": sum(txo['amount'] for txo in outputs if 'address' in txo),
        "signature": payment_req_signer.sign_digest_deterministic(h_pr.digest()).hex(),
    }

class Server(TCPServer):
    def __init__(
        self,
        server_address,
        server_port,
    ):
        TCPServer.allow_reuse_address = True
        super().__init__((server_address, server_port), Server.MyHttpRequestHandler)

    def run(self):
        self.serve_forever()

    class MyHttpRequestHandler(SimpleHTTPRequestHandler):

        def return_error_page(self, error_code, message):
            self.send_response(error_code)
            self.send_header("Content-type", "text/html; charset=utf-8")
            self.end_headers()
            self.wfile.write(bytes(message, "utf8"))

        def do_GET(self):
            try:
                request = urlparse(self.path)
                site = request.path

                host = WABISABI_HOST
                head = WABISABI_HEADERS
                if site.startswith("/swagger"):
                    host = MIDDLEWARE_HOST
                    head = MIDDLEWARE_HEADERS
                
                    # proxy for wabisabi server
                url = f"http://{host}{self.path}"
                resp = requests.get(url, headers=merge_headers(dict(self.headers), head))

                self.send_response(resp.status_code)
                self.send_header("Access-Control-Allow-Origin", self.headers.get("Access-Control-Allow-Origin", "*"))
                self.end_headers()
                self.wfile.write(resp.content)
            except Exception as exception:
                exc_type, exc_value, exc_tb = sys.exc_info()
                message = "<br>".join(
                    traceback.format_exception(exc_type, exc_value, exc_tb)
                )
                self.return_error_page(500, message)

        def do_POST(self, body: bool = True) -> None:
            try:
                request = urlparse(self.path)
                site = request.path
                host = WABISABI_HOST
                head = WABISABI_HEADERS
                data_len = int(self.headers.get("Content-Length", 0))
                data = self.rfile.read(data_len)

                if site.startswith("/payment-request"):
                    params = json.loads(data.decode("utf-8").replace("'",'"'))
                    print(params)
                    signature = make_payment_request(params["recipient_name"], params["outputs"], params["change_addresses"])
                    self.send_response(200)
                    self.send_header("Content-type", "application/json; charset=utf-8")
                    self.send_header("Access-Control-Allow-Origin", self.headers.get("Access-Control-Allow-Origin", "*"))
                    self.end_headers()
                    self.wfile.write(bytes(json.dumps(signature, ensure_ascii=False), 'utf-8'))
                    return

                if site.startswith("/Cryptography"):
                    host = MIDDLEWARE_HOST
                    head = MIDDLEWARE_HEADERS

                url = f"http://{host}{self.path}"
                
                resp = requests.post(url, data=data, headers=merge_headers(dict(self.headers), head))

                self.send_response(resp.status_code)
                self.send_header("Access-Control-Allow-Origin", self.headers.get("Access-Control-Allow-Origin", "*"))
                self.send_header("Content-type", "application/json; charset=utf-8")
                self.send_header("Content-Encoding", "br")
                self.end_headers()
                if body:
                    self.wfile.write(resp.content)
            except Exception as e:
                exc_type, exc_value, exc_tb = sys.exc_info()
                message = traceback.format_exception(exc_type, exc_value, exc_tb)
                print(message)
                self.send_error(404, f"Error processing POST: {self.path} Error: {e}")

        def do_OPTIONS(self):
            self.send_response(200, 'ok')
            self.send_header('Access-Control-Allow-Origin', self.headers.get('Access-Control-Allow-Origin', '*'))
            self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
            self.send_header("Access-Control-Allow-Headers", "X-Requested-With")
            self.send_header("Access-Control-Allow-Headers", "Content-Type")
            self.end_headers()

server = Server(
    server_address="0.0.0.0",
    server_port=8081,
)

server.run()
